"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DBusInterface = void 0;
const types_1 = require("util/types");
class DBusInterface {
    constructor($parent, iface) {
        this.$parent = $parent;
        this.$methods = {};
        this.$methodArgs = {};
        this.$signals = {};
        this.$properties = {};
        this.$callbacks = [];
        this.$sigHandlers = [];
        this.$name = iface['$'].name;
        for (let m = 0; iface.method && m < iface.method.length; ++m) {
            let method = iface.method[m];
            let signature = '';
            let methodName = method['$'].name;
            let args = [];
            for (let argx of method.arg || []) {
                let arg = argx['$'];
                args.push(arg);
                if (arg.direction === 'in')
                    signature += arg.type;
            }
            // add method
            this.$createMethod(methodName, signature, args);
        }
        for (let p = 0; iface.property && p < iface.property.length; ++p) {
            let property = iface.property[p];
            this.$createProp(property['$'].name, property['$'].type, property['$'].access);
        }
        for (let s = 0; iface.signal && s < iface.signal.length; ++s) {
            let signal = iface.signal[s];
            let args = [];
            for (let argx of signal.arg || []) {
                args.push(argx['$']);
            }
            this.$createSignal(signal['$'].name, args);
        }
    }
    $getSigHandler(callback) {
        let index;
        if ((index = this.$callbacks.indexOf(callback)) === -1) {
            index = this.$callbacks.push(callback) - 1;
            this.$sigHandlers[index] = function (messageBody) {
                callback.apply(null, messageBody);
            };
        }
        return this.$sigHandlers[index];
    }
    async on(signame, callback) { return await this.addListener(signame, callback); }
    async off(signame, callback) { return await this.removeListener(signame, callback); }
    async addListener(signame, callback) {
        // http://dbus.freedesktop.org/doc/api/html/group__DBusBus.html#ga4eb6401ba014da3dbe3dc4e2a8e5b3ef
        // An example is "type='signal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'" ...
        let bus = this.$parent.service.bus;
        let signalFullName = bus.mangle(this.$parent.name, this.$name, signame);
        if (!bus.signals.listeners(signalFullName).length) {
            // This is the first time, so call addMatch
            let match = getMatchRule(this.$parent.name, this.$name, signame);
            await bus.dbus().then(d => d.AddMatch(match));
            bus.signals.on(signalFullName, this.$getSigHandler(callback));
        }
        else {
            bus.signals.on(signalFullName, this.$getSigHandler(callback));
        }
    }
    async removeListener(signame, callback) {
        let bus = this.$parent.service.bus;
        let signalFullName = bus.mangle(this.$parent.name, this.$name, signame);
        bus.signals.removeListener(signalFullName, this.$getSigHandler(callback));
        if (!bus.signals.listeners(signalFullName).length) {
            // There is no event handlers for this match
            let match = getMatchRule(this.$parent.name, this.$name, signame);
            await bus.dbus().then(d => d.RemoveMatch(match));
            this.$callbacks.length = 0;
            this.$sigHandlers.length = 0;
        }
    }
    $createMethod(mName, signature, args) {
        this.$methods[mName] = signature;
        this.$methodArgs[mName] = args;
        this[mName] = async (...args) => await this.$callMethod(mName, args);
    }
    async $callMethod(mName, args) {
        let bus = this.$parent.service.bus;
        if (!Array.isArray(args))
            args = Array.from(args); // Array.prototype.slice.apply(args)
        let msg = {
            destination: this.$parent.service.name,
            path: this.$parent.name,
            interface: this.$name,
            member: mName
        };
        if (this.$methods[mName] !== '') {
            msg.signature = this.$methods[mName];
            msg.body = args;
        }
        return await bus.invoke(msg);
    }
    $createProp(propName, propType, propAccess) {
        this.$properties[propName] = { type: propType, access: propAccess };
        Object.defineProperty(this, propName, {
            enumerable: true,
            get: () => this.$readProp(propName),
            set: (val) => this.$writeProp(propName, val).catch(err => console.error(err)),
        });
    }
    async $readProp(propName) {
        let val = await this.$parent.service.bus.invoke({
            destination: this.$parent.service.name,
            path: this.$parent.name,
            interface: 'org.freedesktop.DBus.Properties',
            member: 'Get',
            signature: 'ss',
            body: [this.$name, propName]
        });
        if (Array.isArray(val) && val.length == 1) {
            return val[0];
        }
        return val;
    }
    async $writeProp(propName, val) {
        if ((0, types_1.isPromise)(val)) {
            val = await val;
        }
        return await this.$parent.service.bus.invoke({
            destination: this.$parent.service.name,
            path: this.$parent.name,
            interface: 'org.freedesktop.DBus.Properties',
            member: 'Set',
            signature: 'ssv',
            body: [this.$name, propName, [this.$properties[propName].type, val]]
        });
    }
    $createSignal(mName, args) {
        this.$signals[mName] = args;
    }
}
exports.DBusInterface = DBusInterface;
function getMatchRule(objName, ifName, signame) {
    return `type='signal',path='${objName}',interface='${ifName}',member='${signame}'`;
}
//# sourceMappingURL=dbusInterface.js.map
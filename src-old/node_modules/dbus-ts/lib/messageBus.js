"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageBus = void 0;
const events_1 = require("events");
const stdifaces_1 = require("./utils/stdifaces");
const dbusService_1 = require("./dbusService");
const constants_1 = require("./utils/constants");
class MessageBus {
    constructor(connection, opts = {}) {
        this.connection = connection;
        this.opts = opts;
        this.serial = 1;
        this.cookies = {};
        this.methodCallHandlers = {};
        this.signals = new events_1.EventEmitter();
        this.exportedObjects = {};
        this.connection.on('message', (msg) => this.onMessage(msg));
        // register name
        if (opts.direct !== true) {
            this.invokeDbus({ member: "Hello" }).then(name => [this.name] = name);
        }
        else {
            this.name = null;
        }
    }
    async dbus() {
        if (!this._dbus) {
            this._dbus = await this.getObject('org.freedesktop.DBus', '/org/freedesktop/DBus');
        }
        return this._dbus.as('org.freedesktop.DBus');
    }
    invoke(msg) {
        return new Promise((resolve, reject) => {
            if (!msg.type)
                msg.type = constants_1.messageType.methodCall;
            msg.serial = this.serial++;
            this.cookies[msg.serial] = [resolve, reject];
            this.connection.message(msg);
        });
    }
    invokeDbus(msg) {
        if (!msg.path)
            msg.path = '/org/freedesktop/DBus';
        if (!msg.destination)
            msg.destination = 'org.freedesktop.DBus';
        if (!msg['interface'])
            msg['interface'] = 'org.freedesktop.DBus';
        return this.invoke(msg);
    }
    mangle(path, iface, member) {
        let obj = {};
        if (typeof path === 'object') {
            // handle one argument case mangle(msg)
            obj.path = path.path;
            obj['interface'] = path['interface'];
            obj.member = path.member;
        }
        else {
            obj.path = path;
            obj['interface'] = iface;
            obj.member = member;
        }
        return JSON.stringify(obj);
    }
    sendSignal(path, iface, name, signature, args) {
        let signalMsg = {
            type: constants_1.messageType.signal,
            serial: this.serial++,
            interface: iface,
            path: path,
            member: name
        };
        if (signature) {
            signalMsg.signature = signature;
            signalMsg.body = args;
        }
        this.connection.message(signalMsg);
    }
    sendError(msg, errorName, errorText) {
        let reply = {
            type: constants_1.messageType.error,
            serial: this.serial++,
            replySerial: msg.serial,
            destination: msg.sender,
            errorName: errorName,
            signature: 's',
            body: [errorText]
        };
        this.connection.message(reply);
    }
    sendReply(msg, signature, body) {
        let reply = {
            type: constants_1.messageType.methodReturn,
            serial: this.serial++,
            replySerial: msg.serial,
            destination: msg.sender,
            signature: signature,
            body: body
        };
        this.connection.message(reply);
    }
    onMessage(msg) {
        const self = this;
        function invoke(impl, func, resultSignature) {
            Promise.resolve()
                .then(function () {
                return func.apply(impl, (msg.body || []).concat(msg));
            })
                .then(function (methodReturnResult) {
                let methodReturnReply = {
                    type: constants_1.messageType.methodReturn,
                    serial: self.serial++,
                    destination: msg.sender,
                    replySerial: msg.serial
                };
                if (methodReturnResult !== null) {
                    methodReturnReply.signature = resultSignature;
                    methodReturnReply.body = [methodReturnResult];
                }
                self.connection.message(methodReturnReply);
            }, function (e) {
                self.sendError(msg, e.dbusName || 'org.freedesktop.DBus.Error.Failed', e.message || '');
            });
        }
        let handler;
        if (msg.type === constants_1.messageType.methodReturn ||
            msg.type === constants_1.messageType.error) {
            if (typeof self.cookies[msg.replySerial] !== 'undefined') {
                const [resolve, reject] = self.cookies[msg.replySerial];
                delete self.cookies[msg.replySerial];
                let args = msg.body || [];
                if (msg.type === constants_1.messageType.methodReturn) {
                    resolve(args);
                }
                else {
                    reject(args);
                }
            }
        }
        else if (msg.type === constants_1.messageType.signal) {
            self.signals.emit(self.mangle(msg), msg.body, msg.signature);
        }
        else {
            // methodCall
            if ((0, stdifaces_1.stdDbusIfaces)(msg, self))
                return;
            // exported interfaces handlers
            let obj, iface, impl;
            if ((obj = self.exportedObjects[msg.path])) {
                if ((iface = obj[msg['interface']])) {
                    // now we are ready to serve msg.member
                    impl = iface[1];
                    let func = impl[msg.member];
                    if (!func) {
                        self.sendError(msg, 'org.freedesktop.DBus.Error.UnknownMethod', `Method "${msg.member}" on interface "${msg.interface}" doesn't exist`);
                        return;
                    }
                    // TODO safety check here
                    let resultSignature = iface[0].methods[msg.member][1];
                    invoke(impl, func, resultSignature);
                    return;
                }
                else {
                    // TODO: respond with standard dbus error
                    this.connection.emit('message_error', `Interface ${msg['interface']} is not supported`, msg);
                }
            }
            // setMethodCall handlers
            handler = self.methodCallHandlers[self.mangle(msg)];
            if (handler) {
                invoke(null, handler[0], handler[1]);
            }
            else {
                self.sendError(msg, 'org.freedesktop.DBus.Error.UnknownService', 'Uh oh oh');
            }
        }
    }
    setMethodCallHandler(objectPath, iface, member, handler) {
        let key = this.mangle(objectPath, iface, member);
        this.methodCallHandlers[key] = handler;
    }
    exportInterface(obj, path, iface) {
        const self = this;
        let entry;
        if (!this.exportedObjects[path]) {
            entry = this.exportedObjects[path] = {};
        }
        else {
            entry = this.exportedObjects[path];
        }
        entry[iface.name] = [iface, obj];
        // monkey-patch obj.emit()
        if (typeof obj.emit === 'function') {
            let oldEmit = obj.emit;
            obj.emit = function () {
                let args = Array.prototype.slice.apply(arguments);
                let signalName = args[0];
                if (!signalName)
                    throw new Error('Trying to emit undefined signal');
                //send signal to bus
                let signal;
                if (iface.signals && iface.signals[signalName]) {
                    signal = iface.signals[signalName];
                    let signalMsg = {
                        type: constants_1.messageType.signal,
                        serial: self.serial++,
                        interface: iface.name,
                        path: path,
                        member: signalName
                    };
                    if (signal[0]) {
                        signalMsg.signature = signal[0];
                        signalMsg.body = args.slice(1);
                    }
                    self.connection.message(signalMsg);
                    self.serial++;
                }
                // note that local emit is likely to be called before signal arrives
                // to remote subscriber
                oldEmit.apply(obj, args);
            };
        }
        // TODO: emit ObjectManager's InterfaceAdded
    }
    getService(name) {
        return new dbusService_1.DBusService(name, this);
    }
    async getObject(service, name) {
        return await this.getService(service).getObject(name);
    }
    ;
    async getInterface(service, name, inf) {
        return await this.getService(service).getObject(name).then(s => s.as(inf));
    }
    ;
}
exports.MessageBus = MessageBus;
//# sourceMappingURL=messageBus.js.map
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.clientHandshake = void 0;
const crypto_1 = require("crypto");
const promises_1 = require("fs/promises");
const path_1 = require("path");
const readline_1 = require("./readline");
const constants = __importStar(require("./constants"));
function sha1(input) {
    let shasum = (0, crypto_1.createHash)('sha1');
    shasum.update(input);
    return shasum.digest('hex');
}
function getUserHome() {
    return process.env[process.platform.match(/\$win/) ? 'USERPROFILE' : 'HOME'];
}
async function getCookie(context, id) {
    // http://dbus.freedesktop.org/doc/dbus-specification.html#auth-mechanisms-sha
    let dirname = (0, path_1.join)(getUserHome(), '.dbus-keyrings');
    // > There is a default context, "org_freedesktop_general" that's used by servers that do not specify otherwise.
    if (context.length === 0)
        context = 'org_freedesktop_general';
    let filename = (0, path_1.join)(dirname, context);
    const s = await (0, promises_1.stat)(dirname);
    // check it's not writable by others and readable by user
    if (s.mode & 0o22) {
        throw new Error('User keyrings directory is writeable by other users. Aborting authentication');
    }
    if (process.hasOwnProperty('getuid') && s.uid !== process.getuid()) {
        throw new Error('Keyrings directory is not owned by the current user. Aborting authentication!');
    }
    const keyrings = await (0, promises_1.readFile)(filename, { encoding: 'ascii' });
    const lines = keyrings.split('\n');
    for (let l = 0; l < lines.length; ++l) {
        let data = lines[l].split(' ');
        if (data.length > 2 && id === data[0])
            return data[2];
    }
    throw new Error('cookie not found');
}
function hexlify(input) {
    return Buffer.from(input.toString(), 'ascii').toString('hex');
}
async function clientHandshake(stream, opts) {
    let authMethods = opts?.authMethods || constants.defaultAuthMethods;
    stream.write('\0');
    let uid = opts?.uid;
    if (typeof uid === 'undefined') {
        uid = process?.hasOwnProperty('getuid') ? process.getuid() : 0;
    }
    let id = hexlify(uid);
    let lastErr;
    for (let m of authMethods) {
        try {
            return await tryAuth(stream, m, id);
        }
        catch (e) {
            lastErr = e;
        }
    }
    throw lastErr || new Error("no auth methods available");
}
exports.clientHandshake = clientHandshake;
async function tryAuth(stream, authMethod, id) {
    const successAndBegin = async () => {
        const line = await (0, readline_1.readLine)(stream);
        const ok = line.toString('ascii').match(/^([A-Za-z]+) (.*)/);
        if (ok && ok.length > 2 && ok[1] === 'OK') {
            stream.write('BEGIN\r\n');
            return ok[2]; // ok[2] = guid. Do we need it?
        }
        throw new Error(line.toString('ascii'));
    };
    switch (authMethod) {
        case 'EXTERNAL':
            stream.write(`AUTH ${authMethod} ${id}\r\n`);
            return await successAndBegin();
        case 'DBUS_COOKIE_SHA1':
            stream.write(`AUTH ${authMethod} ${id}\r\n`);
            const line = await (0, readline_1.readLine)(stream);
            let data = Buffer.from(line.toString().split(' ')[1].trim(), 'hex')
                .toString().split(' ');
            let cookieContext = data[0];
            let cookieId = data[1];
            let serverChallenge = data[2];
            // any random 16 bytes should work, sha1(rnd) to make it simplier
            let clientChallenge = (0, crypto_1.randomBytes)(16).toString('hex');
            let cookie = await getCookie(cookieContext, cookieId);
            let response = sha1([serverChallenge, clientChallenge, cookie].join(':'));
            let reply = hexlify(clientChallenge + response);
            stream.write(`DATA ${reply}\r\n`);
            return await successAndBegin();
        case 'ANONYMOUS':
            stream.write('AUTH ANONYMOUS \r\n');
            return await successAndBegin();
        default:
            throw new Error(`Unsupported auth method: ${authMethod}`);
    }
}
//# sourceMappingURL=handshake.js.map
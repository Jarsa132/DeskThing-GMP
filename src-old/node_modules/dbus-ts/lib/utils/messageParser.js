"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.marshallMessage = exports.messageParser = void 0;
const dbusBuffer_1 = require("./dbusBuffer");
const constants_1 = require("./constants");
const marshall_1 = require("./marshall");
const headerSignature = [{
        "type": "a",
        "child": [{
                "type": "(",
                "child": [
                    { "type": "y", "child": [] },
                    { "type": "v", "child": [] }
                ]
            }]
    }];
function messageParser(stream, onMessage, opts) {
    let state = 0; // 0: header, 1: fields + body
    let header, fieldsAndBody;
    let fieldsLength, fieldsLengthPadded;
    let fieldsAndBodyLength = 0;
    let bodyLength = 0;
    stream.on('readable', function () {
        while (1) {
            if (state === 0) {
                header = stream.read(16);
                if (!header)
                    break;
                state = 1;
                fieldsLength = header.readUInt32LE(12);
                fieldsLengthPadded = ((fieldsLength + 7) >> 3) << 3;
                bodyLength = header.readUInt32LE(4);
                fieldsAndBodyLength = fieldsLengthPadded + bodyLength;
            }
            else {
                fieldsAndBody = stream.read(fieldsAndBodyLength);
                if (!fieldsAndBody)
                    break;
                state = 0;
                let messageBuffer = new dbusBuffer_1.DBusBuffer(fieldsAndBody, undefined, opts);
                let unmarshalledHeader = messageBuffer.readArray(headerSignature[0].child[0], fieldsLength);
                messageBuffer.align(3);
                let headerName;
                let message = {};
                message.serial = header.readUInt32LE(8);
                for (let i = 0; i < unmarshalledHeader.length; ++i) {
                    headerName = constants_1.headerTypeName[unmarshalledHeader[i][0]];
                    if (typeof opts.simple !== 'undefined' && !opts.simple) {
                        message[headerName] = unmarshalledHeader[i][1][1][0];
                    }
                    else {
                        message[headerName] = unmarshalledHeader[i][1];
                    }
                }
                message.type = header[1];
                message.flags = header[2];
                if (bodyLength > 0 && message.signature) {
                    message.body = messageBuffer.read(message.signature);
                }
                onMessage(message);
            }
        }
    });
}
exports.messageParser = messageParser;
function marshallMessage(message) {
    if (!message.serial)
        throw new Error('Missing or invalid serial');
    let flags = message.flags || 0;
    let type = message.type || constants_1.messageType.methodCall;
    let bodyLength = 0;
    let bodyBuff;
    if (message.signature && message.body) {
        bodyBuff = (0, marshall_1.marshall)(message.signature, message.body);
        bodyLength = bodyBuff.length;
    }
    let header = [
        constants_1.endianness.le,
        type,
        flags,
        constants_1.protocolVersion,
        bodyLength,
        message.serial
    ];
    let headerBuff = (0, marshall_1.marshall)('yyyyuu', header);
    let fields = [];
    constants_1.headerTypeName.forEach(function (fieldName) {
        let fieldVal = message[fieldName];
        if (fieldVal) {
            fields.push([
                constants_1.headerTypeId[fieldName],
                [constants_1.fieldSignature[fieldName], fieldVal]
            ]);
        }
    });
    let fieldsBuff = (0, marshall_1.marshall)('a(yv)', [fields], 12);
    let headerLenAligned = ((headerBuff.length + fieldsBuff.length + 7) >> 3) << 3;
    let messageLen = headerLenAligned + bodyLength;
    let messageBuff = Buffer.alloc(messageLen);
    headerBuff.copy(messageBuff);
    fieldsBuff.copy(messageBuff, headerBuff.length);
    if (bodyLength > 0)
        bodyBuff.copy(messageBuff, headerLenAligned);
    return messageBuff;
}
exports.marshallMessage = marshallMessage;
//# sourceMappingURL=messageParser.js.map